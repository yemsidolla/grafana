// =============================================================================
// GRAFANA ALLOY CONFIGURATION - CLEAN MULTI-HOST MONITORING
// =============================================================================
// This configuration runs on each Docker host to collect:
// 1. Docker container logs with clear hostname identification
// 2. System logs with clear hostname identification
// 3. Container metrics via cAdvisor
// 4. Forward all data to central Grafana Loki and Prometheus servers
//
// USAGE:
// 1. Deploy this agent on each Docker host you want to monitor
// 2. Set HOSTNAME environment variable to unique host identifier
// 3. Set LOKI_URL to point to central Loki server
// 4. Set PROMETHEUS_URL to point to central Prometheus server
// 5. Agent will automatically discover and monitor all Docker containers
//
// ENVIRONMENT VARIABLES REQUIRED:
// - HOSTNAME: Unique identifier for this host (e.g., "web-server-01")
// - LOKI_URL: Central Loki endpoint (e.g., "http://central-server:3100")
// - PROMETHEUS_URL: Central Prometheus endpoint (e.g., "http://central-server:9090")
// =============================================================================












// =============================================================================
// METRICS CONFIGURATION
// =============================================================================
// Collects container metrics via cAdvisor and forwards to Prometheus

// Host cAdvisor on the Docker socket to expose container metrics
prometheus.exporter.cadvisor "cadvisor" {
  docker_only = true
}

// Relabel cAdvisor targets with proper job and instance labels
discovery.relabel "cadvisor_targets" {
  targets = prometheus.exporter.cadvisor.cadvisor.targets

  rule {
    target_label = "job"
    replacement  = "integrations/docker"
  }

  rule {
    target_label = "instance"
    replacement  = env("HOSTNAME")
  }
}

// Configure a prometheus.scrape component to collect cAdvisor metrics
prometheus.scrape "cadvisor_scraper" {
  targets    = discovery.relabel.cadvisor_targets.output
  forward_to = [prometheus.remote_write.prometheus_output.receiver]
  scrape_interval = "10s"
}

// Configure a prometheus.remote_write component to send metrics to Prometheus server
prometheus.remote_write "prometheus_output" {
  endpoint {
    url = env("PROMETHEUS_URL") + "/api/v1/write"
  }
}






// =============================================================================
// DOCKER CONTAINER LOG COLLECTION
// =============================================================================
// Collects Docker container logs with docker_by_host label for easy filtering

// Discover Docker containers and extract metadata
discovery.docker "docker_discovery" {
  host = "unix:///var/run/docker.sock"
}

// Define a relabeling rule to create a service name from the container name
discovery.relabel "logs_integrations_docker" {
  targets = discovery.docker.docker_discovery.targets
  
  rule {
    source_labels = ["__meta_docker_container_name"]
    regex = "/(.*)"
    target_label = "container_name"
  }

  rule {
    target_label = "instance"
    replacement  = env("HOSTNAME")
  }
}

// Collect Docker container logs
loki.source.docker "docker_logs" {
  host       = "unix:///var/run/docker.sock"
  targets    = discovery.docker.docker_discovery.targets
  relabel_rules = discovery.relabel.logs_integrations_docker.rules
  forward_to = [loki.process.docker_processor.receiver]
}



// Process Docker logs with host identification and log level detection
loki.process "docker_processor" {
  // Extract container name from Docker metadata
  stage.docker {}
  
  // Extract log level from log content
  stage.regex {
    source = "output"
    expression = "(?P<level>ERROR|WARN|INFO|DEBUG|TRACE|FATAL|PANIC|CRITICAL|EMERGENCY)"
  }
  
  // Add level label for filtering
  stage.labels {
    values = {
      level = "level",
    }
  }
  
  // Format log with hostname, service, and level
  stage.template {
    source = "output"
    template = "[HOST: {{ env \"HOSTNAME\" | default \"unknown-host\" }}] [SERVICE: {{ .container }}] [LEVEL: {{ .level | default \"INFO\" }}] {{ .output }}"
  }
  
  stage.static_labels {
    values = {
      docker_by_host = env("HOSTNAME"),
    }
  }
  
  forward_to = [loki.write.loki_output.receiver]
}

// =============================================================================
// SYSTEM LOG COLLECTION
// =============================================================================
// Collects system logs with sys_log label for easy filtering

// Discover system log files to monitor
local.file_match "sys_logs" {
  path_targets = [
    {__path__ = "/var/log/*.log", job = "sys_log"},
    {__path__ = "/var/log/syslog", job = "sys_log"},
    {__path__ = "/var/log/auth.log", job = "sys_log"},
  ]
}

// Tail and collect system log files
loki.source.file "sys_logs" {
  targets    = local.file_match.sys_logs.targets
  forward_to = [loki.process.sys_log_processor.receiver]
  tail_from_end = true
}

// Process system logs with host identification and log level detection
loki.process "sys_log_processor" {
  // Extract log level from log content
  stage.regex {
    source = "output"
    expression = "(?P<level>ERROR|WARN|INFO|DEBUG|TRACE|FATAL|PANIC|CRITICAL|EMERGENCY)"
  }
  
  // Format log with hostname, service, and level
  stage.template {
    source = "output"
    template = "[HOST: {{ env \"HOSTNAME\" | default \"unknown-host\" }}] [SERVICE: system] [LEVEL: {{ .level | default \"INFO\" }}] {{ .output }}"
  }
  
  stage.static_labels {
    values = {
      sys_log = env("HOSTNAME"),
    }
  }
  
  forward_to = [loki.write.loki_output.receiver]
}

// =============================================================================
// FORWARD LOGS TO LOKI
// =============================================================================
loki.write "loki_output" {
  endpoint {
    url = env("LOKI_URL") + "/loki/api/v1/push"
  }
}